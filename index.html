<html>
<button id="cirklar" type="button">Cirklar</button>
<button id="linjer" type="button">Linjer</button>
<button id="start" type="button">Starta</button>
<button onClick="window.location.reload();">Börja om</button>
<button id="sc" type="button">Slumpmässiga cirklar</button>
<input type="range" min="5" max="10" id="slider">
<p>
  För att rita dina egna linjer på canvasen nedan så trycker du på knappen "Linjer". Sedan vänstertrycker på en valfri punkt (som kommer vara den ena ändpunkten
  för linjen) och håll in den knappen. Dra musen till en annan punkt och släpp vänsterknappen på din mus. Då bildas det en linje. Samma gäller för 
  att rita cirklar. Slidern till höger ändrar inte hastigheten, utan hur många gånger tidsloopen körs per loop. Mer information hittas i koden.
</p>
<div>
  <canvas id="canvasNr1" width="1000" height="700" style="border:1px solid #d3d3d3;" />
</div>

<script>

  var context = document.getElementById('canvasNr1').getContext("2d");
  var bildHöjd = document.getElementById('canvasNr1').height;
  var bildVidd = document.getElementById('canvasNr1').width;
  var ritacirklar = document.getElementById("cirklar");
  var ritalinjer = document.getElementById("linjer");

  context.font = "20px Arial";


  // -------------------------------------------------
  // Grafikfunktioner
  // -------------------------------------------------

  // Radie

  function r(x, y) {
    return Math.sqrt(x * x + y * y);
  };

  // Punkt

  function Punkt(x, y, färg = 'black') {
    var H = document.getElementById('canvasNr1').height;
    context.fillStyle = färg;
    context.fillRect(x, H - y, 1, 1);
  };


  // Linje

  function Linje(x1, y1, x2, y2, färg = 'black') {
    var H = document.getElementById('canvasNr1').height;
    context.beginPath();
    context.strokeStyle = färg;
    context.moveTo(x1, H - y1);
    context.lineTo(x2, H - y2);
    context.lineWidth = 2;
    context.stroke();
  };

  // Vektor

  function Vektor(x, y, vx, vy, färg = 'black') {
    Linje(x, y, x + vx, y + vy, färg);
  }

  // Cirkel

  function Cirkel(x, y, r, blå, röd) {
    if(r === undefined){
      r = 2;
    }
    var H = document.getElementById('canvasNr1').height;
    context.beginPath();
    context.arc(x, H - y, r, 0, 2 * Math.PI);
    context.strokeStyle = "black";
    context.lineWidth = 2;
    context.stroke();

    //För att undvika att alla andra cirklar ska bli färgade. 
    if (blå !== undefined) {
      context.strokeStyle = "rgba(1, 1, 1, 0)";
      var färg = "rgb(" + röd + "," + 200 + "," + blå + ")"
      context.fillStyle = färg;
      context.fill();

      context.strokeStyle = färg;
      context.lineWidth = 0;
      context.stroke()
    }
  };

  // Text

  function Text(text, x, y, size, justering) {
    var textVidd = context.measureText(text).width;

    var dx = 0;
    var dy = 0;

    if (justering == 'center')
      dx = textVidd / 2;
    var H = document.getElementById('canvasNr1').height;
    context.font = size + ' Arial';
    context.fillText(text, x - dx, H - y);
  }

  //-----------------------
  // Kod för slumpmässiga cirklar. 
  //-----------------------
  //Välj antalet cirklar med variabeln ac.

  var ac = 30;
  var lc = [];
  document.getElementById("sc").addEventListener("click", function () {
    var xtemp;
    var ytemp;
    var rtemp;
    var distans;
    var distansstart;
    var count = 0;

    while (lc.length < ac) {
      ytemp = Math.random() * bildHöjd;
      xtemp = Math.random() * bildVidd;
      rtemp = Math.random() * 20 + 10;
      lc.push({ x: xtemp, y: ytemp, r: rtemp });

      //Kod som tar bort överlappande cirklar. 
      if (count >= 1) {
        for (i = 0; i < lc.length - 1; i++) {
          distans = Math.sqrt((lc[i].x - lc[count].x) ** 2 + (lc[i].y - lc[count].y) ** 2);
          if (distans < lc[i].r + lc[count].r) {
            // Cirklar överlappar och en av dem tas bort
            lc.splice(count, 1);
            count--;
          }
        }
      }
      count++;
    }

    //Ritar alla dessa cirklar
    for (i = 0; i < lc.length; i++) {
      Cirkel(lc[i].x, lc[i].y, lc[i].r);
    }
  })


  // ----------------------------
  // Kod där du kan rita cirklar och linjer helt fritt på canvasen. 
  // ----------------------------
  var ritatyp;
  ritacirklar.addEventListener("click", function () {
    ritatyp = "cirklar";
  });

  ritalinjer.addEventListener("click", function () {
    ritatyp = "linjer";
  });

  var llinjer = [];
  var x1, x2, y1, y2, muspos;

  window.addEventListener('mousedown', function (e) {
    muspos = getMousePos(document.getElementById('canvasNr1'), e);
    x1 = muspos.x;
    y1 = muspos.y;
  });

  window.addEventListener('mouseup', function (e) {
    muspos = getMousePos(document.getElementById('canvasNr1'), e);
    x2 = muspos.x;
    y2 = muspos.y;

    if (ritatyp === "linjer") {
      llinjer.push({ x1: x1, y1: y1, x2: x2, y2: y2 });
      Linje(x1, y1, x2, y2);
    }

    if (ritatyp === "cirklar") {
      lc.push({ x: x1, y: y1, r: Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) });
      Cirkel(x1, y1, Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2));
    }
  });

  function getMousePos(canvas, e) {
    // Denna funktion är nödvändig eftersom e.clientX samt e.clientY (eller t.ex e.pageX och e.pageY) inte mäter
    // vart på CANVASEN musen befinner sig i och mäter istället vart på HELA hemsidan (relativt till din skärm) musen befinner sig i. 
    // canvas.getBoundingClientRect() "återvänder" (return) ett objekt som innehåller vart canvasen sitter. 
    var rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      // Jag subtraherar e.clientY - rect.top från bildHöjd eftersom origo i en canvas sitter längst upp i vänstra hörnet
      // men alla rit-funktioner, såsom Linjer, Cirklar osv, kräver att origo sitter längst ner i vänstra hörnet. 
      y: bildHöjd - (e.clientY - rect.top)
    };
  }

  // -------------------------------------------------
  // Fysik
  // -------------------------------------------------


  // Startposition

  // var x0 = 30;
  // var y0 = 20;
  // var x0 = bildVidd / 2;
  // var y0 = bildHöjd - 20;

  // Listan "streckax/y" kommer att användas för att hitta nedslagspunkten.
  var streckax = [];
  var streckay = [];
  var x0 = 0;
  var y0 = 0;

  // Utgångshastighet i x- och y-led

  // var v0x = 10;
  // var v0y = -50;
  var v0 = 50;
  var alfa0 = 30;
  alfa0 = alfa0 * 3.14 / 180;
  var v0x = v0 * Math.cos(alfa0);
  var v0y = v0 * Math.sin(alfa0);


  var kl = 0.00012;
  // var km = 0.012;
  // var kl = 0;
  // var km = 0.00011;
  var km = 0.002;
  var g = 1;

  var m = 0.0459;

  // Utgångsacceleration i x- och y-led

  // var a0x = 0;
  // var a0y = -3;

  var a0x = -kl * v0 ** 2 / m * Math.cos(alfa0) - km * v0 / m * Math.sin(alfa0);
  var a0y = -g - kl * v0 ** 2 / m * Math.sin(alfa0) + km * v0 / m * Math.cos(alfa0);

  // Position och hastighet då t = 0

  var x = x0;
  var y = y0;

  var vx = v0x;
  var vy = v0y;

  var ax = a0x;
  var ay = a0y;

  // Tiden
// 0.6 fel
//0.5 rätt
  var tMax = 100;
  var dt = 0.01;                                   // Att stega fram tiden med.
  var visaSteg = 10;                             // Alla tidssteg kan inte visas. 
  var stegRäknare = 0;
  var ttemp = 0;

  // -------------------------------------------------
  // Loop över tiden
  // -------------------------------------------------

  var intervall;
  var räknastart = 0;
  var sliderv = 5;
  document.getElementById("slider").oninput = function () {
    sliderv = this.value;
  }

  document.getElementById("start").addEventListener("click", function () {
    //Gör så att man inte kan trycka på start flera gånger eftersom den då sätter flera intervall vilket är oönskat. 
    if (räknastart === 0) {
      // Sätter ett intervall för att se bollen röra sig i action. En loop "stoppar" koden tills den är klar, dvs. tills allt redan är ritat. 
      intervall = setInterval(
        function () {
          // ttemp += 0.08;
          ttemp += 0.02;
          for (i = 0; i < sliderv; i++) {
            tidsLoop();
          }
        }, 0
      )
    }
    räknastart++;
  })


  function tidsLoop() {
    var vtot = Math.sqrt((vx) ** 2 + (vy) ** 2)
    if (ttemp > tMax) {
      // Tiden har "stoppats". 
      clearInterval(intervall)
    }
    if (stegRäknare % visaSteg == 0) {
      var blå = 255 * vtot * 0.2;
      var röd = 255 / vtot * 11;
      Cirkel(x, y, 2, blå, röd);
      //Notera att en rosa färg indikerar att hastigheten är liten, en gul att hastigheten är väldigt liten och en blå att den är stor. 
    }

    // Ny position från hastigheten
    var xförr = x;    //Sparar x samt y koordinaten för att bollen inte ska "fastna" vid en vägg. 
    var yförr = y;
    x += vx * dt;
    y += vy * dt;

    streckax.push(x);
    streckay.push(y);

    // Ny hastighet från accelerationen

    vx += ax * dt;
    vy += ay * dt;

    if (vx < 0 & kl > 0) {
      kl = -kl;
    }

    if (vx > 0 & kl < 0) {
      kl = -kl;
    }

    var alfa = Math.atan(vy / vx);

    ax = -kl * vtot**2  / m * Math.cos(alfa) - km * vtot / m * Math.sin(alfa);
    ay = -g - kl * vtot**2  / m * Math.sin(alfa) + km * vtot / m * Math.cos(alfa);

    if (x >= bildVidd || x <= 0) {
      vx = -vx;
      // Tappar en viss andel rörelse energi vid en studs. 
      vx *= 0.85;
      km *= 0.1;
      // För att partikeln inte ska "fastna" i en vägg. 
      x = xförr;
    }

    if (y >= bildHöjd || y <= 0) {
      vy = -vy;
      //Tappar en viss andel rörelse energi vid en studs
      vy *= 0.85;
      vx *= 0.85;
      km *= 0.1;

      if(y <= 0){
        // Använder y = kx + m
        var k = (streckay[streckay.length-2] - streckay[streckay.length-1])/(streckax[streckay.length-2] - streckax[streckay.length-1]);
        var mvärde = streckay[streckay.length-1] - k*streckax[streckax.length-1];
        var nedpunkt = -mvärde/k;
        Cirkel(nedpunkt, 0, 5);
        console.log(nedpunkt)
      }

      // För att partikeln inte ska "fastna" i en vägg. 
      y = yförr;
    }

    //--------------------------
    //TRÄFFAR EN CIRKEL. 
    //--------------------------
    for (var i = 0; i < lc.length; i++) {
      var d = Math.sqrt((lc[i].x - x) ** 2 + (lc[i].y - y) ** 2);
      if (d <= lc[i].r) {
        // Tappar en viss andel rörelse energi. E_k = (v^2)/2 om massan redan är "inbakad" i ekvationen => v = sqrt(2E_k). 
        vy *= 0.85;
        y = yförr;
        x = xförr;
        km *= 0.1;
        studsa(lc[i].x, lc[i].y, "cirkel");
      }
    }
    //--------------------------
    //TRÄFFAR EN LINJE
    //--------------------------
    for (var i = 0; i < llinjer.length; i++) {
      // Räknar ut det kortaste avståndet mellan alla linjer och partikeln enligt sats 6.3.2.
      var klinje = (llinjer[i].y1 - llinjer[i].y2) / (llinjer[i].x1 - llinjer[i].x2);
      var mlinje = llinjer[i].y2 - (klinje * llinjer[i].x2);

      var täljare = Math.abs(-klinje * x + y - mlinje);
      var nämnare = Math.sqrt(klinje ** 2 + 1);
      var distlinje = täljare / nämnare;

      if (distlinje <= 1 && llinjer[i].x1 < x == x < llinjer[i].x2) {
        // Tappar en viss andel rörelse energi 
        vy *= 0.85;
        y = yförr;
        x = xförr;
        km *= 0.1;
        studsa(1, 1, "linje", klinje);
      }
    }

    stegRäknare++
  }


  function studsa(xkomp, ykomp, typ, k) {
    if (typ === "cirkel") {
      var knormen = (ykomp - y) / (xkomp - x);
    } else {
      var knormen = -1 / k;
    }

    var vinkel = Math.atan(knormen);
    var normen = { x: Math.cos(vinkel), y: Math.sin(vinkel) };

    var hastighetnu = { x: vx, y: vy };
    // v_2 = v_1 -2 * <n, v_1> * n enligt sats 6.3.1.
    // Delar upp ekvationen i sats 6.3.1 för att slippa en otroligt lång rad. 
    var skalär = -2 * (normen.x * hastighetnu.x + normen.y * hastighetnu.y);
    var skalärgnormen = { x: skalär * normen.x, y: skalär * normen.y };
    var hastighetefter = { x: hastighetnu.x + skalärgnormen.x, y: hastighetnu.y + skalärgnormen.y };
    vx = hastighetefter.x;
    vy = hastighetefter.y;
  }
</script>

</body>

</html>
